<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html data-lt-installed="true" class=" kffexgx idc0_341"><head>

  <title>td4</title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="GENERATOR" content="Mozilla/3.04Gold (X11; I; SunOS 5.7 sun4u) [Netscape]">

</head>

<body vlink="#52188C" text="#000000" link="#0000EF" bgcolor="#FFFFFF" alink="#FF0000">



<div align="left"></div>

<table width="800">

  <tbody><tr>

    <td width="78">  <p align="center"><img src="sujet_files/logo_utc_new.jpg" width="180" height="60" align="MIDDLE"></p></td>



    <td>  <p align="center"><b><font size="+3"><font color="#006699">SR01 - TD 4 </font></font></b></p>  <p align="center"><b><font size="+3"><font color="#006699">Structures de contrôle, boucles, <br>

      Fonctions et passage de paramètres </font></font></b></p></td>

  </tr>

  </tbody></table>



<!-- ****************************-->

<hr width="800" align="left">

<p><b><i><font color="#0000FF"><font size="+1" color="#006699">Ex1&nbsp;: fichier&nbsp; ex1.c</font></font></i></b></p>



<p>Ecrire une fonction qui récupère une chaîne de caractères

  et qui affiche&nbsp;:</p>



<ul>

  <li>Le longueur total de la chaîne</li>



  <li>Le nombre de caractères majuscules</li>



  <li>Le nombre de caractères minuscules</li>



  <li>Le nombre des blancs </li>



  <li>Le nombre des autres caractères </li>

</ul>



<p>Vous pouvez utiliser la fonction <i>fgets() </i>pour lire la chaine de

  caractères (au lieu de <i>scanf()</i>)<br>

  Tester votre fonction dans le main.</p>

<!-- ****************************-->

<hr width="800" align="left">

<p><b><font color="#0000FF"><font size="+1" color="#006699">Ex2&nbsp;: fichiers ex2a.c, ex2b.c

  ex2c.c</font></font></b></p>



<p><b><i><font color="#006699">Ex2a.c</font></i></b>&nbsp;: A l'aide de plusieurs boucles for() imbriquées,

  réaliser le dessin d'un arbre de sapin&nbsp;:<br>

  (Utiliser la constante symbolique TAILLE pour la&nbsp; largeur du sapin&nbsp;:&nbsp;

  #define TAILLE&nbsp; 10&nbsp; )</p>



<pre>
         *

        ***

       *****

      *******

     *********

    ***********

   *************

  ***************

 *****************

*******************

       ||||

       ||||

       ||||

       ||||



</pre>



<p><b><font color="#006699">Ex2b.c</font>&nbsp;</b>: En ajoutant encore des boucles for() , afficher

  dans cette version une forêt de sapin.<br>

  (Utiliser la constante symbolique NBRE pour le nombre des arbres&nbsp;:&nbsp;

  #define NBRE 3&nbsp;)<br>

</p>



<pre>


         *                   *                   *

        ***                 ***                 ***

       *****               *****               *****

      *******             *******             *******

     *********           *********           *********

    ***********         ***********         ***********

   *************       *************       *************

  ***************     ***************     ***************

 *****************   *****************   *****************

******************* ******************* *******************

        ||||                ||||                ||||

        ||||                ||||                ||||

        ||||                ||||                ||||

        ||||                ||||                ||||

        ||||                ||||                ||||







</pre>


<!-- ****************************-->

<hr width="800" align="left">

<p><font color="#006699"><b><i><font size="+1">Ex3&nbsp;: fichier ex3a.c&nbsp; ex3b.c</font></i></b></font></p>



<p><b><font color="#006699">Ex3a.c</font>&nbsp;</b>: Ecrire la fonction <i>matrice_info() </i>qui récupère

  une matrice d'entiers et qui affiche&nbsp;:</p>



<ul>

  <li>Le nombre des éléments positifs</li>



  <li>Le nombre des éléments négatifs</li>



  <li>Le nombre des zéros,</li>



  <li>Et si le nombre de zéros dépasse le 80% d'éléments,

    la fonction affiche «&nbsp;matrice creuse&nbsp;»</li>

</ul>



<p><b>Important</b>: Le compilateur a toujours besoin de la taille de la

  seconde dimension(nombre de colonnes)<br>

  pour calculer l'adresse d'un élément; <br>

  En effet pour la matrice (int tab[N][M]), l'élément <i>tab[i][j]

  </i>se trouve à l'adresse <i>tab + (i*M+j)*sizeof(int)</i></p>



<p>Vous pouvez donc passer la matrice avec l'une de methodes suivantes:</p>



<p><i>void matrice_info(int tab[N][M])<br>

  void matrice_info(int tab[][M])<br>

  void matrice_info(int (*tab)[M]) </i></p>



<p><b><font color="#006699">Ex3b.c</font></b><font color="#006699">&nbsp;:</font> Ecrire une fonction <i>matrice_creuse() </i>qui

  récupère une matrice initialisée d'entiers et un vecteur

  d'entier <br>

  et qui range tous les éléments non nuls de la matrice dans

  le vecteur. <br>

  En plus la fonction retourne la valeur 1 si la matrice est creuse , 0 sinon.</p>



<p>Tester à chaque fois vos fonctions dans le main. </p>





<!-- ****************************-->

<hr width="800" align="left">

<p><b><i><font color="#0000FF"><font size="+1" color="#006699">Ex4&nbsp;: jeu d'allumettes&nbsp;ex4.c</font></font></i></b></p>



<p>(pour tester le jeu vous pouvez lancer ~sr01/td/td4/ex4)<br>

  Un certain nombre d'allumettes est disposé entre les deux partis,

  l'ordinateur et vous. Le but du jeu est <br>

  de ne pas retirer la dernière allumette. Pour se faire, une prise

  maximale est désignée par le joueur.<br>

  En début de partie, on demande :</p>



<p>1. Le nombre d'allumettes disposées entre les deux joueur (de

  10 à 60).<br>

  2. Le nombre maximal d'allumettes que l'on peut retirer.<br>

  3. Qui commence (0 pour le joueur et 1 pour l'ordinateur).</p>



<p>Puis, tour à tour, chaque parti donne le nombre d'allumettes

  qu'il prend. La partie se termine lorsqu'il n y a plus <br>

  d'allumettes sur la table. La personne ayant tirée la dernière

  allumette est le perdant, l'autre le vainqueur.</p>



<p>L'ordinateur répond grâce à la fonction décrite

  ci-dessous :</p>



<p><i>int jeu_ordi (int nb_allum, int prise_max)<br>

  {<br>

  int prise = 0;<br>

  int s = 0;<br>

  float t = 0;<br>

  s = prise_max + 1;<br>

  t = ((float) (nb_allum - s)) / (prise_max + 1);<br>

  while (t != floor (t))<br>

  <span style="">&nbsp; </span>{<br>

  <span style="">&nbsp;&nbsp; </span>s--;<br>

  <span style="">&nbsp;&nbsp; </span>t = ((float) (nb_allum-s)) / (prise_max

  + 1);<br>

  <span style="">&nbsp; </span>}<br>

  prise = s - 1;<br>

  if (prise == 0)<br>

  prise = 1;<br>

  return (prise);<br>

  }</i></p>



<ul style="margin-left: 40px;">

  <li>Nb_allum est le nombre d'allumettes sur la table (au moment du coup

    à jouer).</li>



  <li>Prise_max est le nombre maximum d'allumettes autorisé lors d'une

    prise.</li>



  <li>La fonction retourne en sortie le nombre d'allumettes prises par l'ordinateur.&nbsp;

    <br>

    <i>Exemple :</i>prise = jeu_ordi (10,3) ;</li>



  <li>La fonction floor donne l'arrondi inférieur d'un nombre, elle&nbsp;nécessite

    la bibliothèque &lt;math.h&gt;<br>

    L'utilisation de la bibliothèque &lt;math.h&gt; oblige à

    linker avec -lm : &gt;gcc -o prog prog.c -lm</li>

</ul>



<p>voici la déclaration des variables locales dans le main()&nbsp;:</p>



<p>int main ()<br>

  {<br>

  int nb_max_d=0; /*nbre d'allumettes maxi au départ*/<br>

  int nb_allu_max=0; /*nbre d'allumettes maxi que l?on peut tirer au maxi*/<br>

  int qui=0; /*qui joue? 0=Nous --- 1=PC*/<br>

  int prise=0; /*nbre d'allumettes prises par le joueur*/<br>

  int nb_allu_rest=0; /*nbre d'allumettes restantes*/<br>

  ....</p>



<p>Après chaque jeu le programme affiche les allumettes qui restent&nbsp;:

  <br>

  ceci est à réaliser dans la fonction&nbsp;: void afficher_allumettes(int

  n)<br>

  voici le resultat de l'appel de&nbsp; afficher_allumettes(10);<br>

</p>

<pre>
 o o o o o o o o o o

 | | | | | | | | | |

</pre>

<br>



<!-- ****************************-->

<hr width="800" align="left">

<p><b><i><font color="#0000FF"><font size="+1" color="#006699">Ex5&nbsp;: jeu de la vie &nbsp;ex5.c</font></font></i></b></p>

<!-- P>(pour tester le jeu vous pouvez lancer ~sr01/td/td4/jeuvie2)<BR>-->

<p>

  Le Jeu de la vie est l'exemple le plus connu d'automate cellulaire.

  Ce jeu, décrit en 1970 par le mathématicien John Conway <br>

  de l'université de Cambridge, vise à modéliser d'une fa�on simple l'évolution d'organismes vivants.

</p>

Le jeu de la vie évolue normalement sur un damier infini. Chaque case est occupée par une cellule

qui peut �tre vivante ou morte. <br>

A chaque génération, chaque cellule peut na�tre, mourir, ou rester dans son état.

Les r�gles qui permettent de passer d'une <br>

génération à l'autre sont précises et ont été choisies avec soin pour

que l'évolution des organismes soit intéressante et imprévisible. <br>

En premier lieu, notons que sur un damier

infini, chaque case a exactement 8 voisins.

Pour créer la génération suivante à partir <br>

de la génération courante,

J. Conway a fixé les règles suivantes :

<ul>

  <li>Une cellule ayant exactement 2 ou 3 voisins vivants survit  la génération suivante.</li>

  <li>Une cellule ayant au moins 4 cellules voisines vivantes meurt d'étouffement à la génération suivante.</li>

  <li>Une cellule ayant au plus une cellule voisine vivante meurt d'isolement à la génération suivante.</li>

  <li>Sur une case vide ayant exactement 3 voisins vivants, une cellule na�tra à la génération suivante.</li>

</ul>



Afin d'implémenter ce jeu, on considère le damier infini comme une matrice "torique". Le damier sera représenté par une matrice <br>

dont les bords droite et gauche sont reliés entre eux, ainsi que les bords supérieur et inférieur.



<p>

  Codez ce jeu, en découpant soigneusement votre programme en plusieurs fonctions

  (fonction d'initialisation du damier , fonction <br>

  de calcul de nombre de voisins, fonction d'affichage, ...)

</p>

<p>

  Vous pouvez utiliser la fonction rand() pour l'initialisation du damier.

</p>

Soignez l'affichage, pour pouvoir suivre l'évolution des cellules d'une génération à l'autre.





</body></html>